<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Scheme Generator</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
        }
        
        .description {
            text-align: center;
            margin-bottom: 30px;
            color: #666;
        }
        
        .description a {
            color: #3498db;
        }
        
        .section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .section h2 {
            margin-top: 0;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }
        
        input[type="number"], select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: #3498db;
        }
        
        .target-colors-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .target-color-input {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .target-color-input input[type="color"] {
            width: 50px;
            height: 35px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .target-color-input input[type="text"] {
            width: 80px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background-color 0.2s;
        }
        
        .btn-primary {
            background-color: #3498db;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #2980b9;
        }
        
        .btn-primary:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background-color: #95a5a6;
            color: white;
        }
        
        .btn-secondary:hover {
            background-color: #7f8c8d;
        }
        
        .buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .color-row {
            margin-bottom: 20px;
        }
        
        .color-row-label {
            font-weight: 600;
            margin-bottom: 10px;
            color: #555;
        }
        
        .color-boxes {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        
        .color-box {
            width: 80px;
            height: 80px;
            border-radius: 4px;
            border: 1px solid #ddd;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 5px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .color-box:hover {
            transform: scale(1.05);
        }
        
        .color-box span {
            font-size: 10px;
            font-family: monospace;
            background: rgba(255,255,255,0.8);
            padding: 2px 4px;
            border-radius: 2px;
        }
        
        .progress-container {
            margin-top: 15px;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .progress-bar-fill {
            height: 100%;
            background-color: #3498db;
            transition: width 0.1s;
        }
        
        .progress-text {
            text-align: center;
            margin-top: 10px;
            color: #666;
            font-size: 14px;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stat-box {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .weight-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .weight-input {
            display: flex;
            flex-direction: column;
        }
        
        .weight-input label {
            font-size: 13px;
        }
        
        .weight-input input {
            width: 100%;
        }
        
        .info-text {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <h1>ðŸŽ¨ Color Scheme Generator</h1>
    <p class="description">
        Generate accessible and attractive color schemes based on 
        <a href="https://matthewstrom.com/writing/how-to-pick-the-least-wrong-colors" target="_blank">Matthew Strom's work</a>.
    </p>
    
    <div class="section">
        <h2>Configuration</h2>
        
        <div class="form-group">
            <label for="paletteSize">Palette Size (number of colors)</label>
            <input type="number" id="paletteSize" value="5" min="2" max="12">
        </div>
        
        <div class="form-group">
            <label for="initMethod">Initialization Method</label>
            <select id="initMethod">
                <option value="random">Random Colors</option>
                <option value="target">From Target Colors</option>
            </select>
        </div>
        
        <div class="form-group" id="targetColorsSection">
            <label>Target Colors (click to edit)</label>
            <div id="targetColorsContainer" class="target-colors-container"></div>
            <button class="btn btn-secondary" onclick="addTargetColor()">+ Add Color</button>
        </div>
        
        <h3>Optimization Weights</h3>
        <div class="weight-group">
            <div class="weight-input">
                <label for="energyWeight">Energy Weight</label>
                <input type="number" id="energyWeight" value="1" step="0.1" min="0">
                <span class="info-text">Higher = more differentiable colors</span>
            </div>
            <div class="weight-input">
                <label for="rangeWeight">Range Weight</label>
                <input type="number" id="rangeWeight" value="1" step="0.1" min="0">
                <span class="info-text">Higher = more uniform spread</span>
            </div>
            <div class="weight-input">
                <label for="targetWeight">Target Weight</label>
                <input type="number" id="targetWeight" value="1" step="0.1" min="0">
                <span class="info-text">Higher = closer to target colors</span>
            </div>
            <div class="weight-input">
                <label for="protanopiaWeight">Protanopia Weight</label>
                <input type="number" id="protanopiaWeight" value="0.33" step="0.1" min="0">
                <span class="info-text">Higher = better for protanopia</span>
            </div>
            <div class="weight-input">
                <label for="deuteranopiaWeight">Deuteranopia Weight</label>
                <input type="number" id="deuteranopiaWeight" value="0.33" step="0.1" min="0">
                <span class="info-text">Higher = better for deuteranopia</span>
            </div>
            <div class="weight-input">
                <label for="tritanopiaWeight">Tritanopia Weight</label>
                <input type="number" id="tritanopiaWeight" value="0.33" step="0.1" min="0">
                <span class="info-text">Higher = better for tritanopia</span>
            </div>
        </div>
        
        <h3>Algorithm Parameters</h3>
        <div class="weight-group">
            <div class="weight-input">
                <label for="temperature">Initial Temperature</label>
                <input type="number" id="temperature" value="1000" step="100" min="1">
            </div>
            <div class="weight-input">
                <label for="coolingRate">Cooling Rate</label>
                <input type="number" id="coolingRate" value="0.99" step="0.01" min="0.01" max="0.999">
            </div>
            <div class="weight-input">
                <label for="cutoff">Cutoff Temperature</label>
                <input type="number" id="cutoff" value="0.0001" step="0.0001" min="0.0001">
            </div>
        </div>
        
        <div class="buttons" style="margin-top: 20px;">
            <button class="btn btn-primary" id="optimizeBtn" onclick="startOptimization()">ðŸš€ Optimize Colors</button>
            <button class="btn btn-secondary" onclick="generateRandomColors()">ðŸŽ² Generate Random</button>
        </div>
    </div>
    
    <div class="section">
        <h2>Results</h2>
        
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
                <div class="progress-bar-fill" id="progressBarFill" style="width: 0%"></div>
            </div>
            <div class="progress-text" id="progressText">Ready to optimize</div>
        </div>
        
        <div class="stats">
            <div class="stat-box">
                <div class="stat-label">Start Cost</div>
                <div class="stat-value" id="startCost">-</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Current Cost</div>
                <div class="stat-value" id="currentCost">-</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Improvement</div>
                <div class="stat-value" id="improvement">-</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Iterations</div>
                <div class="stat-value" id="iterations">-</div>
            </div>
        </div>
        
        <div style="margin-top: 30px;">
            <div class="color-row">
                <div class="color-row-label">Starting Colors</div>
                <div class="color-boxes" id="startColors"></div>
            </div>
            
            <div class="color-row">
                <div class="color-row-label">Optimized Colors</div>
                <div class="color-boxes" id="endColors"></div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // Section 1: Utility Functions
        // ============================================
        
        function randomElementFromArray(array) {
            if (!array || array.length === 0) {
                throw new Error("Input array is empty.");
            }
            return array[Math.floor(Math.random() * array.length)];
        }
        
        function randomNFromArray(array, n) {
            if (!array || array.length === 0) {
                throw new Error("Input array is empty.");
            }
            if (n < 0 || n > array.length) {
                throw new Error("Invalid value of 'n'.");
            }
            const shuffled = [...array].sort(() => 0.5 - Math.random());
            return shuffled.slice(0, n);
        }
        
        function randomRgbColor() {
            return [
                Math.floor(Math.random() * 256),
                Math.floor(Math.random() * 256),
                Math.floor(Math.random() * 256)
            ];
        }
        
        function randomNearbyColor(color) {
            const channelToChange = Math.floor(Math.random() * 3);
            const oldVal = color[channelToChange] / 255;
            let newVal = oldVal + (Math.random() - 0.5) * 0.1; // -0.05 to 0.05
            newVal = Math.max(0, Math.min(1, newVal));
            
            const newColor = [...color];
            newColor[channelToChange] = Math.floor(newVal * 255);
            return newColor;
        }
        
        function average(array) {
            if (!array || array.length === 0) return 0;
            return array.reduce((a, b) => a + b, 0) / array.length;
        }
        
        function deepCopy(arr) {
            return arr.map(item => Array.isArray(item) ? [...item] : item);
        }
        
        // ============================================
        // Section 2: Color Conversion Functions
        // ============================================
        
        function rgbToLab(inputColor) {
            function _f(t) {
                if (t > 0.008856) {
                    return Math.pow(t, 1/3);
                } else {
                    return 7.787 * t + 16/116;
                }
            }
            
            let [R, G, B] = inputColor;
            R = R / 255.0;
            G = G / 255.0;
            B = B / 255.0;
            
            // sRGB to XYZ
            R = R > 0.04045 ? _f((R + 0.055) / 1.055) : R / 12.92;
            G = G > 0.04045 ? _f((G + 0.055) / 1.055) : G / 12.92;
            B = B > 0.04045 ? _f((B + 0.055) / 1.055) : B / 12.92;
            
            let X = R * 0.4124564 + G * 0.3575761 + B * 0.1804375;
            let Y = R * 0.2126729 + G * 0.7151522 + B * 0.0721750;
            let Z = R * 0.0193339 + G * 0.1191920 + B * 0.9503041;
            
            // XYZ to Lab
            X /= 0.95047;
            Y /= 1.0;
            Z /= 1.08883;
            
            X = _f(X);
            Y = _f(Y);
            Z = _f(Z);
            
            const L = 116 * Y - 16;
            const a = 500 * (X - Y);
            const b = 200 * (Y - Z);
            
            return [L, a, b];
        }
        
        function srgbFromLinearRgb(value) {
            if (value <= 0) return 0;
            if (value >= 1) return 255;
            if (value < 0.0031308) {
                return Math.floor(0.5 + value * 12.92 * 255);
            }
            return Math.floor(0 + 255 * (Math.pow(value, 1.0 / 2.4) * 1.055 - 0.055));
        }
        
        function linearRgbFromSrgb(value) {
            const fv = value / 255.0;
            if (fv < 0.04045) {
                return fv / 12.92;
            }
            return Math.pow((fv + 0.055) / 1.055, 2.4);
        }
        
        // Precompute lookup table
        const srgbToLinearRgbLookup = (function() {
            const lookup = [];
            for (let i = 0; i < 256; i++) {
                lookup.push(linearRgbFromSrgb(i));
            }
            return lookup;
        })();
        
        function hexToRgb(hexColor) {
            if (!hexColor.startsWith('#') || hexColor.length !== 7) {
                throw new Error("Input must be a hex color string in the format '#RRGGBB'.");
            }
            const r = parseInt(hexColor.slice(1, 3), 16);
            const g = parseInt(hexColor.slice(3, 5), 16);
            const b = parseInt(hexColor.slice(5, 7), 16);
            return [r, g, b];
        }
        
        function rgbToHex(rgb) {
            const toHex = (c) => {
                const hex = Math.max(0, Math.min(255, Math.round(c))).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            };
            return '#' + toHex(rgb[0]) + toHex(rgb[1]) + toHex(rgb[2]);
        }
        
        // ============================================
        // Section 3: Distance Functions
        // ============================================
        
        function deltaECiede2000(color1Lab, color2Lab) {
            const [L1, a1, b1] = color1Lab;
            const [L2, a2, b2] = color2Lab;
            
            const C1 = Math.sqrt(a1**2 + b1**2);
            const C2 = Math.sqrt(a2**2 + b2**2);
            const Cabbar = (C1 + C2) / 2;
            
            const G = 0.5 * (1 - Math.sqrt(Cabbar**7 / (Cabbar**7 + 25**7)));
            const a1prime = a1 * (1 + G);
            const a2prime = a2 * (1 + G);
            
            const C1prime = Math.sqrt(a1prime**2 + b1**2);
            const C2prime = Math.sqrt(a2prime**2 + b2**2);
            
            let h1prime = Math.atan2(b1, a1prime);
            if (h1prime < 0) h1prime += 2 * Math.PI;
            let h2prime = Math.atan2(b2, a2prime);
            if (h2prime < 0) h2prime += 2 * Math.PI;
            
            const deltaLprime = L2 - L1;
            const deltaCprime = C2prime - C1prime;
            let deltahprime = h2prime - h1prime;
            
            if (C1prime * C2prime !== 0) {
                if (Math.abs(deltahprime) <= Math.PI) {
                    // deltahprime = deltahprime
                } else if (deltahprime > Math.PI) {
                    deltahprime -= 2 * Math.PI;
                } else {
                    deltahprime += 2 * Math.PI;
                }
            }
            
            const deltaHprime = 2 * Math.sqrt(C1prime * C2prime) * Math.sin(deltahprime / 2);
            
            const Lbar = (L1 + L2) / 2;
            const Cbarprime = (C1prime + C2prime) / 2;
            let hbarprime = (h1prime + h2prime) / 2;
            
            if (C1prime * C2prime !== 0) {
                if (Math.abs(h1prime - h2prime) > Math.PI) {
                    hbarprime += Math.PI;
                }
            }
            
            const T = 1 - 0.17 * Math.cos(hbarprime - Math.PI/6) +
                0.24 * Math.cos(2 * hbarprime) +
                0.32 * Math.cos(3 * hbarprime + Math.PI/30) -
                0.20 * Math.cos(4 * hbarprime - 63 * Math.PI / 180);
            
            const SL = 1 + ((0.015 * (Lbar - 50)**2) / Math.sqrt(20 + (Lbar - 50)**2));
            const SC = 1 + 0.045 * Cbarprime;
            const SH = 1 + 0.015 * Cbarprime * T;
            
            const RT = -2 * Math.sqrt(Cbarprime**7 / (Cbarprime**7 + 25**7)) *
                Math.sin(60 * Math.PI / 180 * Math.exp(-(((hbarprime - 275 * Math.PI / 180) / (25 * Math.PI / 180))**2)));
            
            const deltaE = Math.sqrt(
                (deltaLprime / SL)**2 +
                (deltaCprime / SC)**2 +
                (deltaHprime / SH)**2 +
                RT * (deltaCprime / SC) * (deltaHprime / SH)
            );
            
            return deltaE;
        }
        
        function distance(color1, color2) {
            let color1Rgb, color2Rgb;
            
            if (typeof color1 === 'string' && color1.includes('#')) {
                color1Rgb = hexToRgb(color1);
            } else {
                color1Rgb = color1;
            }
            
            if (typeof color2 === 'string' && color2.includes('#')) {
                color2Rgb = hexToRgb(color2);
            } else {
                color2Rgb = color2;
            }
            
            const color1Lab = rgbToLab(color1Rgb);
            const color2Lab = rgbToLab(color2Rgb);
            
            return deltaECiede2000(color1Lab, color2Lab);
        }
        
        function distances(colorArray, visionSpace = "Normal") {
            const processedColors = colorArray.map(c => brettelFunctions[visionSpace](c));
            const distanceValues = [];
            
            for (let i = 0; i < processedColors.length; i++) {
                for (let j = i + 1; j < processedColors.length; j++) {
                    distanceValues.push(distance(processedColors[i], processedColors[j]));
                }
            }
            
            return distanceValues;
        }
        
        function getClosestColor(color, colorArray) {
            let minDistance = null;
            let closestColor = null;
            
            for (const colorOption of colorArray) {
                const currentDistance = distance(color, colorOption);
                if (minDistance === null || currentDistance < minDistance) {
                    minDistance = currentDistance;
                    closestColor = colorOption;
                }
            }
            
            return closestColor;
        }
        
        function distanceRange(array) {
            if (array.length < 2) return 0;
            const sorted = [...array].sort((a, b) => a - b);
            return sorted[sorted.length - 1] - sorted[0];
        }
        
        function averageDistanceFromTargetColors(colors, targetColors) {
            const distanceList = colors.map(c => distance(c, getClosestColor(c, targetColors)));
            return average(distanceList);
        }
        
        // ============================================
        // Section 4: Brettel Functions
        // ============================================
        
        const brettelParams = {
            protan: {
                rgbCvdFromRgb_1: [
                    0.1451, 1.20165, -0.34675, 0.10447, 0.85316, 0.04237, 0.00429,
                    -0.00603, 1.00174,
                ],
                rgbCvdFromRgb_2: [
                    0.14115, 1.16782, -0.30897, 0.10495, 0.8573, 0.03776, 0.00431,
                    -0.00586, 1.00155,
                ],
                separationPlaneNormal: [0.00048, 0.00416, -0.00464],
            },
            deutan: {
                rgbCvdFromRgb_1: [
                    0.36198, 0.86755, -0.22953, 0.26099, 0.64512, 0.09389, -0.01975,
                    0.02686, 0.99289,
                ],
                rgbCvdFromRgb_2: [
                    0.37009, 0.8854, -0.25549, 0.25767, 0.63782, 0.10451, -0.0195,
                    0.02741, 0.99209,
                ],
                separationPlaneNormal: [-0.00293, -0.00645, 0.00938],
            },
            tritan: {
                rgbCvdFromRgb_1: [
                    1.01354, 0.14268, -0.15622, -0.01181, 0.87561, 0.13619, 0.07707,
                    0.81208, 0.11085,
                ],
                rgbCvdFromRgb_2: [
                    0.93337, 0.19999, -0.13336, 0.05809, 0.82565, 0.11626, -0.37923,
                    1.13825, 0.24098,
                ],
                separationPlaneNormal: [0.0396, -0.02831, -0.01129],
            },
        };
        
        function brettel(srgb, t, severity) {
            const rgb = srgb.map(c => srgbToLinearRgbLookup[c]);
            
            const params = brettelParams[t];
            const separationPlaneNormal = params.separationPlaneNormal;
            const dotProduct = rgb.reduce((sum, r, i) => sum + r * separationPlaneNormal[i], 0);
            const rgbCvdFromRgb = dotProduct >= 0 ? params.rgbCvdFromRgb_1 : params.rgbCvdFromRgb_2;
            
            const rgbCvd = [];
            for (let i = 0; i < 9; i += 3) {
                let sum = 0;
                for (let j = 0; j < 3; j++) {
                    sum += rgbCvdFromRgb[i + j] * rgb[j];
                }
                rgbCvd.push(sum);
            }
            
            const result = rgbCvd.map((c, i) => c * severity + rgb[i] * (1.0 - severity));
            
            return result.map(c => srgbFromLinearRgb(c));
        }
        
        function monochromeWithSeverity(srgb, severity) {
            const z = Math.round(srgb[0] * 0.299 + srgb[1] * 0.587 + srgb[2] * 0.114);
            const r = z * severity + (1.0 - severity) * srgb[0];
            const g = z * severity + (1.0 - severity) * srgb[1];
            const b = z * severity + (1.0 - severity) * srgb[2];
            return [Math.floor(r), Math.floor(g), Math.floor(b)];
        }
        
        const brettelFunctions = {
            Normal: (v) => v,
            Protanopia: (v) => brettel(v, "protan", 1.0),
            Protanomaly: (v) => brettel(v, "protan", 0.6),
            Deuteranopia: (v) => brettel(v, "deutan", 1.0),
            Deuteranomaly: (v) => brettel(v, "deutan", 0.6),
            Tritanopia: (v) => brettel(v, "tritan", 1.0),
            Tritanomaly: (v) => brettel(v, "tritan", 0.6),
            Achromatopsia: (v) => monochromeWithSeverity(v, 1.0),
            Achromatomaly: (v) => monochromeWithSeverity(v, 0.6),
        };
        
        // ============================================
        // Section 5: Cost Functions
        // ============================================
        
        function cost(state, targetColors, weights) {
            const {
                energyWeight,
                rangeWeight,
                targetWeight,
                protanopiaWeight,
                deuteranopiaWeight,
                tritanopiaWeight
            } = weights;
            
            const normalDistances = distances(state);
            const protanopiaDistances = distances(state, "Protanopia");
            const deuteranopiaDistances = distances(state, "Deuteranopia");
            const tritanopiaDistances = distances(state, "Tritanopia");
            
            const energyScore = 100 - average(normalDistances);
            const protanopiaScore = 100 - average(protanopiaDistances);
            const deuteranopiaScore = 100 - average(deuteranopiaDistances);
            const tritanopiaScore = 100 - average(tritanopiaDistances);
            const rangeScore = distanceRange(normalDistances);
            const targetScore = averageDistanceFromTargetColors(state, targetColors);
            
            return (
                energyWeight * energyScore +
                targetWeight * targetScore +
                rangeWeight * rangeScore +
                protanopiaWeight * protanopiaScore +
                deuteranopiaWeight * deuteranopiaScore +
                tritanopiaWeight * tritanopiaScore
            );
        }
        
        // ============================================
        // Section 6: Optimization
        // ============================================
        
        async function optimize(n, inputColors, targetColors, weights, params, progressCallback) {
            let colors;
            
            if (inputColors.length === 0) {
                colors = Array.from({ length: n }, () => randomRgbColor());
            } else if (inputColors.length !== n) {
                throw new Error(`Please provide ${n} starting colors.`);
            } else {
                colors = deepCopy(inputColors);
            }
            
            let { temperature, coolingRate, cutoff } = params;
            
            // Calculate total iterations for progress
            const totalIterations = Math.ceil(Math.log(cutoff / temperature) / Math.log(coolingRate));
            let idx = 0;
            
            while (temperature > cutoff) {
                for (let i = 0; i < colors.length; i++) {
                    const newColors = deepCopy(colors);
                    newColors[i] = randomNearbyColor(newColors[i]);
                    
                    const newColorCost = cost(newColors, targetColors, weights);
                    const oldColorCost = cost(colors, targetColors, weights);
                    
                    if (newColorCost < oldColorCost) {
                        colors[i] = newColors[i];
                    }
                }
                
                temperature *= coolingRate;
                idx++;
                
                // Update progress every 10 iterations to keep UI responsive
                if (idx % 10 === 0 && progressCallback) {
                    const progress = Math.min(100, (idx / totalIterations) * 100);
                    const currentCost = cost(colors, targetColors, weights);
                    await progressCallback(progress, idx, currentCost, colors);
                    // Allow UI to update
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            // Final progress update
            if (progressCallback) {
                const currentCost = cost(colors, targetColors, weights);
                await progressCallback(100, idx, currentCost, colors);
            }
            
            return colors;
        }
        
        // ============================================
        // Section 7: UI Functions
        // ============================================
        
        let targetColorsArray = [
            "#9966FF",
            "#0055BC",
            "#00A1C2",
            "#ED6804",
            "#B3063D"
        ];
        
        let startColorsArray = [];
        let endColorsArray = [];
        let isOptimizing = false;
        
        function renderTargetColors() {
            const container = document.getElementById('targetColorsContainer');
            container.innerHTML = '';
            
            targetColorsArray.forEach((color, index) => {
                const div = document.createElement('div');
                div.className = 'target-color-input';
                div.innerHTML = `
                    <input type="color" value="${color}" onchange="updateTargetColor(${index}, this.value)">
                    <input type="text" value="${color}" onchange="updateTargetColorFromText(${index}, this.value)">
                    <button class="btn btn-secondary" style="padding: 5px 10px;" onclick="removeTargetColor(${index})">Ã—</button>
                `;
                container.appendChild(div);
            });
        }
        
        function updateTargetColor(index, value) {
            targetColorsArray[index] = value.toUpperCase();
            renderTargetColors();
        }
        
        function updateTargetColorFromText(index, value) {
            if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
                targetColorsArray[index] = value.toUpperCase();
                renderTargetColors();
            }
        }
        
        function addTargetColor() {
            targetColorsArray.push('#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0').toUpperCase());
            renderTargetColors();
        }
        
        function removeTargetColor(index) {
            if (targetColorsArray.length > 1) {
                targetColorsArray.splice(index, 1);
                renderTargetColors();
            }
        }
        
        function renderColorBoxes(colors, containerId) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            colors.forEach(color => {
                const rgb = Array.isArray(color) ? color : hexToRgb(color);
                const hex = rgbToHex(rgb);
                const div = document.createElement('div');
                div.className = 'color-box';
                div.style.backgroundColor = hex;
                
                // Determine text color based on brightness
                const brightness = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
                const textColor = brightness > 128 ? '#000' : '#fff';
                
                div.innerHTML = `<span style="color: ${textColor}">${hex}</span>`;
                div.onclick = () => copyToClipboard(hex);
                div.title = 'Click to copy';
                container.appendChild(div);
            });
        }
        
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                // Could show a toast notification here
            });
        }
        
        function getWeights() {
            return {
                energyWeight: parseFloat(document.getElementById('energyWeight').value),
                rangeWeight: parseFloat(document.getElementById('rangeWeight').value),
                targetWeight: parseFloat(document.getElementById('targetWeight').value),
                protanopiaWeight: parseFloat(document.getElementById('protanopiaWeight').value),
                deuteranopiaWeight: parseFloat(document.getElementById('deuteranopiaWeight').value),
                tritanopiaWeight: parseFloat(document.getElementById('tritanopiaWeight').value)
            };
        }
        
        function getParams() {
            return {
                temperature: parseFloat(document.getElementById('temperature').value),
                coolingRate: parseFloat(document.getElementById('coolingRate').value),
                cutoff: parseFloat(document.getElementById('cutoff').value)
            };
        }
        
        function generateRandomColors() {
            const paletteSize = parseInt(document.getElementById('paletteSize').value);
            startColorsArray = Array.from({ length: paletteSize }, () => randomRgbColor());
            endColorsArray = [...startColorsArray];
            
            renderColorBoxes(startColorsArray, 'startColors');
            renderColorBoxes(endColorsArray, 'endColors');
            
            const weights = getWeights();
            const startCost = cost(startColorsArray, targetColorsArray.map(hexToRgb), weights);
            
            document.getElementById('startCost').textContent = startCost.toFixed(2);
            document.getElementById('currentCost').textContent = startCost.toFixed(2);
            document.getElementById('improvement').textContent = '0.00';
            document.getElementById('iterations').textContent = '0';
            document.getElementById('progressBarFill').style.width = '0%';
            document.getElementById('progressText').textContent = 'Ready to optimize';
        }
        
        async function startOptimization() {
            if (isOptimizing) return;
            
            isOptimizing = true;
            document.getElementById('optimizeBtn').disabled = true;
            
            const paletteSize = parseInt(document.getElementById('paletteSize').value);
            const initMethod = document.getElementById('initMethod').value;
            const weights = getWeights();
            const params = getParams();
            
            let inputColors;
            if (initMethod === 'target') {
                // Use target colors, sampling if needed
                const targetRgb = targetColorsArray.map(hexToRgb);
                if (targetRgb.length >= paletteSize) {
                    inputColors = randomNFromArray(targetRgb, paletteSize);
                } else {
                    // Fill remaining with random colors
                    inputColors = [...targetRgb];
                    while (inputColors.length < paletteSize) {
                        inputColors.push(randomRgbColor());
                    }
                }
            } else {
                inputColors = Array.from({ length: paletteSize }, () => randomRgbColor());
            }
            
            startColorsArray = deepCopy(inputColors);
            renderColorBoxes(startColorsArray, 'startColors');
            
            const targetRgbColors = targetColorsArray.map(hexToRgb);
            const startCost = cost(startColorsArray, targetRgbColors, weights);
            
            document.getElementById('startCost').textContent = startCost.toFixed(2);
            document.getElementById('progressText').textContent = 'Optimizing...';
            
            try {
                endColorsArray = await optimize(
                    paletteSize,
                    inputColors,
                    targetRgbColors,
                    weights,
                    params,
                    async (progress, iterations, currentCost, currentColors) => {
                        document.getElementById('progressBarFill').style.width = progress + '%';
                        document.getElementById('currentCost').textContent = currentCost.toFixed(2);
                        document.getElementById('improvement').textContent = (startCost - currentCost).toFixed(2);
                        document.getElementById('iterations').textContent = iterations;
                        document.getElementById('progressText').textContent = `Iteration ${iterations} - ${progress.toFixed(1)}%`;
                        renderColorBoxes(currentColors, 'endColors');
                    }
                );
                
                const endCost = cost(endColorsArray, targetRgbColors, weights);
                
                document.getElementById('progressText').textContent = 'Optimization complete!';
                document.getElementById('currentCost').textContent = endCost.toFixed(2);
                document.getElementById('improvement').textContent = (startCost - endCost).toFixed(2);
                
                renderColorBoxes(endColorsArray, 'endColors');
            } catch (error) {
                console.error('Optimization error:', error);
                document.getElementById('progressText').textContent = 'Error: ' + error.message;
            }
            
            isOptimizing = false;
            document.getElementById('optimizeBtn').disabled = false;
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            renderTargetColors();
            generateRandomColors();
            
            // Show/hide target colors section based on init method
            document.getElementById('initMethod').addEventListener('change', (e) => {
                document.getElementById('targetColorsSection').style.display = 
                    e.target.value === 'target' ? 'block' : 'none';
            });
        });
    </script>
</body>
</html>
